[{"id":1,"question":"What is an example of dynamic binding?","code":"","reference":"","choices":["any method","method overloading","method overriding","compiling"],"answer":[2]},{"id":2,"question":"For which case would the use of a static attribute be appropriate?","code":"","reference":"","choices":["the number of people in each house in a small neighborhood","the lot size for each house in a small neighborhood","the color of each house in a small neighborhood","the weather conditions for each house in a small neighborhood"],"answer":[3]},{"id":3,"code":"","reference":"","choices":["to avoid redundant coding in children","to explore a hypothetical class","to prevent unwanted method implementation","to reserve memory for an unspecified class type"],"answer":[0]},{"id":4,"code":"","reference":"","choices":["to have common behavior in derived classes","to explore a hypothetical class","to prevent unwanted method implementation","to reserve memory for an unspecified class type"],"answer":[0]},{"id":5,"code":"","reference":"","choices":["only when you export","both at compile time and runtime","at compile time","at runtime"],"answer":[2]},{"id":6,"code":"","reference":"","choices":["It will result in code that is more extensible and maintainable","It will result in a more compact product.","It will speed initial development.","It will allow you to add that design pattern to your resume."],"answer":[0]},{"id":7,"code":"","reference":"","choices":["defining classes by focusing on what is important for a purpose","hiding the data and implementation details within a class","making all methods private","using words to define classes"],"answer":[1]},{"id":8,"code":"","reference":"","choices":["It implies encapsulation.","A superclass object has an IS-A relationship with its subclass.","It implies a virtual method.","A subclass object has an IS-A relationship with its superclass or interface"],"answer":[3]},{"id":9,"code":"","reference":"","choices":["an abstract method","a public internal method","an internal method","a protected internal method"],"answer":[0]},{"id":10,"code":"","reference":"","choices":["Employee currentEmployee = Employee.Create();","Employee currentEmployee = new Employee();","Employee currentEmployee;","Employee currentEmployee = Employee.New();"],"answer":[1]},{"id":11,"code":"","reference":"","choices":["default","copy","parameterized","Constructors do not have a return type"],"answer":[3]},{"id":12,"code":"","reference":"","choices":["when an object is created from a class using the new keyword","when an class is defined using the class keyword","every time an object is referenced","when an object is created from a class using the create keyword"],"answer":[0]},{"id":13,"code":"","reference":"","choices":["when an object is created from a class","when an class is defined using the class keyword","every time an object is referenced","when an object is created from a class using the create keyword"],"answer":[0]},{"id":14,"code":"","reference":"","choices":["The object can be accessed, declared, and used locally in that function.","The object must be declared inside any other function.","The object is temporarily accessible outside the function.","The object can call all the other class members anywhere in the program."],"answer":[0]},{"id":15,"code":"","reference":"","choices":["do and check","catching and trying","try and catch","do and while"],"answer":[2]},{"id":16,"code":"","reference":"","choices":["It makes it easier to save the entity.","all of these answers","It can make the entity retrieval more efficient","It minimizes coupling."],"answer":[1]},{"id":17,"code":"","reference":"","choices":["Inheritance describes the ability to create new classes based on an existing class.","Inheritance means that a group of related properties, methods, and other members are treated as a single unit or object.","Inheritance forces a class to have a single responsibility from only one parent.","Inheritance means that you will never have multiple classes that can be used interchangeably, even though each class implements the same properties or methods in different ways."],"answer":[0]},{"id":18,"code":"","reference":"","choices":["multilevel","hierarchical and multiple","hierarchical","multiple"],"answer":[2]},{"id":19,"code":"","reference":"","choices":["A default parameter's constructor is not equivalent to the default constructor","A default constructor is inherited from a parent class","A default constructor can be called explicitly","A default constructor cannot be defined by the coder"],"answer":[0]},{"id":20,"code":"","reference":"","choices":["Getters and setters can speed up compilation.","Getters and setters provide encapsulation of behavior.","Getters and setters provide a debugging point for when a property changes at runtime.","Getters and setters permit different access levels."],"answer":[0]},{"id":21,"code":"","reference":"","choices":["Association is a relationship where all objects have their own life cycle and there is no owner.","Association is the process where model elements cooperate to provide higher-level behavior.","Association is whole/part relationship where one object is composed of one or more other objects, each of which is considered a part of the whole.","Association is where all objects have their own life cycle, but there is ownerhip, and child objects can not belong to another parent object."],"answer":[0]},{"id":22,"code":"","reference":"","choices":["User Stories are shorter and less detailed.","User stories are more accurate.","User stories are more detailed and structured.","User storised are more anecdotal and personal."],"answer":[0]},{"id":23,"code":"_NOTE_: Hybrid inheritance is a composition of multiple and hierarchical inheritances","reference":"_NOTE_: Hybrid inheritance is a composition of multiple and hierarchical inheritances","choices":["multiple","any type of inheritance","multilevel","hierarchical"],"answer":[0,3]},{"id":24,"code":"","reference":"","choices":["an object-based language","a class-based language","a procedure-oriented language","if classes are supported, polymorphism will be supported"],"answer":[0]},{"id":25,"code":"","reference":"","choices":["Abstraction is using a private access specifier for data members","Abstraction is using public member functions to access and manipulate the data members","Abstraction is using the class concept with both data members and member functions","There is insufficient information to decide where abstraction is being used."],"answer":[1]},{"id":26,"code":"","reference":"","choices":["Observer, State, Strategy, Template Method, and Visitor.","Composite, Visitor, State, Prototype, and Singleton.","Composite, Builder, Factory Method, Prototype, and Singleton.","Abstract Factory, Builder, Factory Method, Prototype, and Singleton."],"answer":[3]},{"id":27,"code":"","reference":"","choices":["one class only","two classes","as many classes as required","at least two classes"],"answer":[0]},{"id":28,"code":"","reference":"","choices":["to the main object of the caller function, too","on the caller function object and also the called function object","on the copy of the object that is made during the pass","only in the local scope of the called function"],"answer":[0]},{"id":29,"code":"","reference":"","choices":["a set of instructions designed to perform a frequently used operation within a program and return no values","the exact same thing as a function and subroutine","a set of variables that can change over time","a procedure associated with data and behaviour"],"answer":[1]},{"id":30,"code":"","reference":"","choices":["camera","display","motherboard","mobile phone"],"answer":[3]},{"id":31,"code":"","reference":"","choices":["the class at the third level","the class at the first level","All have the same degree of abstraction.","the class at the second level"],"answer":[1]},{"id":32,"code":"","reference":"","choices":["multilevel inheritance","double inheritance","single inheritance","hierarchical inheritance"],"answer":[1]},{"id":33,"code":"","reference":"","choices":["The duplication uses unnecessary space.","One has to maintain all the duplicates.","Duplication can cause intellectual property concerns.","Duplication is easy to hide."],"answer":[1]},{"id":34,"code":"","reference":"","choices":["It is called initially when an object is created and called with every new object instance.","It is called when an object is destroyed and only one time.","It is called initially when an object is created and only one time.","It is created at time when the object is discarded."],"answer":[2]},{"id":35,"code":"cpp    static void Multiply(int num1, int num2) {};    static void Multiply(double num1, double num2, double num3) {};    static void Multiply(float num1, float num2) {};","reference":"```","choices":["polymorphism, because each method can perform different task","method overriding, because it display the same method name, different or same parameters, and same return type","method overloading, because it allows the creation of several methods with the same name, wich differ by the type of input via parameter","method overriding, because it display the same method name, different parameters, and same return type"],"answer":[2]},{"id":36,"code":"","reference":"","choices":["to initialize all the members with static value","to delete the static members when not required","to initialize the static members of class","to clear all the static members' initialized values"],"answer":[0]},{"id":37,"code":"","reference":"","choices":["Code Responsibility Collection cards are a brainstorming tool used in the design of procedural software","Class Responsibility collaboration cards are a brainstorming tool used in the design of oop software","Code Responsibility Correction cards are tools used for debugging","Code Responsibility Correction cards are tools for modeling"],"answer":[1]},{"id":38,"code":"","reference":"","choices":["if one element of an aggregation is dereferenced, all its elements are eligible for garbage collection","if a composition dies, the contents die","the contents of a composition are all siblings","an aggregation contains only abstract classes"],"answer":[1]},{"id":39,"code":"","reference":"","choices":["if one element of an aggregation is dereferenced, all its elements are eligible for garbage collection","if a composition dies, the contents die","the contents of a composition are all siblings","an aggregation contains only abstract classes"],"answer":[1]},{"id":40,"code":"","reference":"","choices":["it can increase code vulnerability","it can make code unsafe","it can limit code readability","it can be safer for coding"],"answer":[2]},{"id":41,"code":"","reference":"","choices":["Member functions can be defined only inside or outside the class body.","Member functions can be made to be friends of another class.","Member functions do not need to be declared inside the class definition.","All member functions need to be defined."],"answer":[2]},{"id":42,"code":"_NOTE_: I don't have 4th variant in my test, it changed to new 5th variant. Is it also true?","reference":"_NOTE_: I don't have 4th variant in my test, it changed to new 5th variant. Is it also true?","choices":["to protect attributes from unwanted changes","to delegate coding responsibility more efficiently","to conserve memory","to avoid writing duplicate code","to separate class behavior from the more general"],"answer":[3,4]},{"id":43,"code":"","reference":"","choices":["a name","a state","a color","an object"],"answer":[0]},{"id":44,"code":"","reference":"","choices":["inline function","undefined function","virtual function","class member function"],"answer":[2]},{"id":45,"code":"","reference":"","choices":["leaf and tree","clean, enrage, and collapse","clean, active, and lively","leaf, tree, and trumpet"],"answer":[3]},{"id":46,"code":"","reference":"","choices":["It focuses on objects that interact cleanly with one another.","It programs exclusively to interfaces.","It programs exclusively to classes.","It creates one class for all business logic."],"answer":[0]},{"id":47,"code":"","reference":"","choices":["No, abstract classes can be used only in single-level inheritance since they must be immediately implemented.","yes, always","yes, but with only one abstract class","No, abstract classes do not have constructors."],"answer":[1]},{"id":48,"code":"","reference":"","choices":["single level","multilevel","hierarchical","multiple"],"answer":[3]},{"id":49,"code":"","reference":"","choices":["Abstraction is about making relevant information visible, while encapsulation enables a programmer to implement the desired level of abstraction.","Abstraction and encapsulation are essentially the same.","Abstraction and encapsulation are unrelated.","Encapsulation is about making relevant information visible, while abstraction enables a programmer to implement the desired level of encapsulation."],"answer":[0]},{"id":50,"code":"","reference":"","choices":["abstract and public","public and private","this and final","final and abstract"],"answer":[1]},{"id":51,"code":"","reference":"","choices":["It is the address of variable only -- not the method of an object.","It is a shallow pointer that contains address of an object.","It is the physical address of an object.","It is the address where the variables and methods of an object are stored."],"answer":[3]},{"id":52,"code":"","reference":"","choices":["Objects may maintain internal state, which is not easily accessible by the tests.","The quality of unit testing frameworks for functional languages is better.","OOP promotes code reuse, which means that your tests have to consider more use cases.","Object-oriented languages tend to rely on frameworks such as Spring or Hibernate, which make them difficult to test."],"answer":[0]},{"id":53,"code":"","reference":"","choices":["It connects actors to use cases.","It links actors to roles played in all use cases.","It lists all actors for each use case.","It minimizes the number of actors required."],"answer":[1]},{"id":54,"code":"","reference":"","choices":["Behaviour describe dynamic properties; attributes are static.","Attributes describe a state; behaviours describe a change.","Attributes apply only to a specified object; behaviour apply to other linked objects.","Behaviours are vector quantities; attributes are scalars."],"answer":[1]},{"id":55,"code":"","reference":"","choices":["refactoring; duplication","modification; duplication","extension; modification","reuse; encapsulation"],"answer":[2]},{"id":56,"code":"","reference":"","choices":["to define a method that must be implemented in a derived class","to define a custom implementation of an inherited member","to define a method that must be implemented in a superclass only","to define a class that can be inherited from"],"answer":[1]},{"id":57,"code":"","reference":"","choices":["It is a unique constructor for creating a new object as a copy of an object that already exists. There will always be only one copy constructor that can be either defined by the user or the system.","It is a constructor that duplicates itself when requested on demand.","It is a common constructor for preventing the creation of a new object as a copy of an object that already exists. There will always be multiple standard constructors that can be either defined by the user or the system.","It is a constructor that duplicates itself on its own, based on memory available."],"answer":[0]},{"id":58,"code":"","reference":"","choices":["The catch block that will be executed is the one that best matches the type of exception thrown.","Multiple catch blocks can never be associated with a single try block.","Multiple catch blocks are mandatory for each try block.","Multiple catch blocks will all be executed in the case of an exception."],"answer":[0]},{"id":59,"code":"","reference":"","choices":["A","B","C","C and B"],"answer":[0]},{"id":60,"code":"","reference":"","choices":["Cohesion. A solution is to show that each module has certain responsibilities and to use an anticohesive design pattern.","Encapsulation. A solution is to implement one of the SOLID principles to ensure the modules do not encapsulate with each other.","Coupling. A solution is to refactor the code to be loosely coupled by using inversion of control and dependency injection.","Dependency. A solution is to implement polymorphism and abstraction to change and extract dependent elements of a module so that it functions on its own."],"answer":[2]},{"id":61,"code":"","reference":"","choices":["A class of resources","A group of methods","A collection of objects","A list of children"],"answer":[2]},{"id":62,"code":"","reference":"","choices":["virtual function","inline function","undefined function","private function"],"answer":[0]},{"id":63,"code":"","reference":"","choices":["loose coupling","code reusability","lazy initialization","data abstraction"],"answer":[0]},{"id":64,"code":"","reference":"","choices":["Yes, the caller function needs to reflect the changes.","No, you should use a global variable instead.","No, changes will be automatically reflected in the calling function.","Yes, the object must be the same in the caller function."],"answer":[2]},{"id":65,"code":"","reference":"","choices":[],"answer":[]},{"id":66,"code":"","reference":"","choices":["car:toyota","ducks:pond","toes:feet","rock:stone"],"answer":[0]},{"id":67,"code":"","reference":"","choices":["Memento notifies multiple classes of changes. Observer captures and restores an object's internal state.","Memento defers the exact steps of an algorithm to a subclass. Observer defines a new operation to a class without change.","Memento alters an object's behavior when its state changes. Observer encapsulates an algorithm inside a class.","Memento captures and restores an object's internal state. Observer notifies multiple classes of changes."],"answer":[3]},{"id":68,"code":"","reference":"","choices":["a default value of the Coordinate attribute","the size of the position array","an increment of the position attribute value","a default value of the position attribute"],"answer":[3]},{"id":69,"code":"public class Car{ } public class FlyingCars extends Car{    public void fly(){} } public class Tesla FlyingCar{} public class Honda Car{}   public class Car{    public void fly(){} } public class Tesla extends Car{} public class Honda extends Car{}   public class Car{ public void fly(){} } public class Tesla Car{} public class Honda Car{}   public class Car{ } public class FlyingCars extends Car{    public void fly(){} } public class Tesla extends FlyingCar{} public class Honda extends Car{}","reference":"```","choices":[null,null,null,null],"answer":[3]},{"id":70,"code":"","reference":"","choices":["An argument can have many values while a parameter can have only one value.","An argument is the variable used for input values in a method. A parameter is the specific input value passed to the method.","A parameter is a variable in the declaration of a function. An argument is the value of this variable that gets passed to the function.","Parameters and arguments are the same"],"answer":[2]},{"id":71,"code":"> Explanation: It depends on the access specifier and the type of inheritance used with the class, because if the class is inherited then the nested class can be used by subclass too, provided it’s not of private type.","reference":"> Explanation: It depends on the access specifier and the type of inheritance used with the class, because if the class is inherited then the nested class can be used by subclass too, provided it’s not of private type.","choices":["Protected scope","Private scope","Global scope","Depends on access specifier and inheritance used"],"answer":[3]},{"id":72,"code":"","reference":"","choices":["a collection","a variable","a class","a procedure"],"answer":[2]},{"id":73,"code":"","reference":"","choices":["Multilevel","Hybrid","Single level","Multiple"],"answer":[0]},{"id":74,"code":"","reference":"","choices":["All of these answers","Applications are decomposed into parts","Parts are defined with minimal overlap","Each part is responsible for a separate concern"],"answer":[0]},{"id":75,"code":"","reference":"","choices":["To always run the finally block of code when the try block exits","To run code when an exception has not occurred","To run the block if an exception occurred","To run code whenever garbage collection requires it"],"answer":[0]},{"id":76,"code":"","reference":"","choices":["C#","Java","C","Python"],"answer":[2]},{"id":77,"code":"","reference":"","choices":["To relinquish resources that are no longer needed","To delete a variable name","To reset an attribute value","To hold space, even after an object is no longer being used"],"answer":[0]},{"id":78,"code":"","reference":"","choices":["Protected class","Base class","Anonymous class","Abstract class"],"answer":[3]},{"id":79,"code":"","reference":"","choices":["Composition is the act of one object passing to another object an operation to be performed on behalf of the initial object.","Composition is a part/hole relationship where an object is composed of one or more other objects, each of which is considered a part of the whole.","Composition is a binding where the class/name association is not made until the object designated by the name is created at execution time","Composition is a process of collecting classes that provide a set of services for a particular domain"],"answer":[1]},{"id":80,"code":"","reference":"","choices":["overloading","inheritance","abstraction","overriding"],"answer":[0]},{"id":81,"code":"","reference":"","choices":["parents","pure virtual functions","attributes","purposes"],"answer":[1]},{"id":82,"code":"","reference":"","choices":["It can be difficult to identify variables that are incorrectly typed","The dynamic variables can assume only limited values","Storage is fixed for dynamic variables","Static variables are more flexible than dynamic variables"],"answer":[0]},{"id":83,"code":"","reference":"","choices":["Early binding is when a variable is assigned a value when a scope is created. Late binding is when a variable is assigned a value after a scope is exited","Early binding is when a variable is assigned a value when the program starts. Late binding is when a variable is assigned after the program is running","There is no difference. In both cases, variables are assigned values when a program has completed startup and is running","Early binding is when a variable is assigned its value at compile time. Late binding is when a variable is assigned a value at run time"],"answer":[3]},{"id":84,"code":"","reference":"","choices":["Interfaces can contain code or data. Abstract classes do not contain code or data. A class can inherit from more than one abstract class but can only implement one interface","Interfaces can contain code or data. Abstract classes do not contain code or data. A class can inherit from only one abstract class but can implement an unlimited number of interface","Abstract classes can contain code or data. Interface do not contain code or data. A class can inherit from only one abstract class but can implement an unlimited number of interfaces","Abstract classes can contain code or data. Interface do not contain code or data. A class can inherit from more than one abstract class but can only implement one interface"],"answer":[2]},{"id":85,"code":"`Here they haven't mentioned any specific language so let's consider all languages.`","reference":"`Here they haven't mentioned any specific language so let's consider all languages.`","choices":["reference to subclass // References to subclass are never required as you can simply Initialize subclass & use their object.","reference to base class // References to the base class are not required in Java, Javascript & Python","reference to this pointer // While Python & Javascript may require passing this or self in the constructor, It is not passed in Java constructor.","none // Above 3 are incorrect so \"none\" is the answer"],"answer":[3]}]